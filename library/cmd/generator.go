package main

import (
	"fmt"
	"go/ast"
	"go/types"
	"log"
	"os"
	"sort"
	"strings"
	"unicode"

	"golang.org/x/tools/go/packages"
)

type PackageData struct {
	CorePackagePath    string
	Core1_0PackagePath string
	SortedPackages     []string
	InstancePackages   map[string]*packages.Package
	DevicePackages     map[string]DeviceStruct
}

type DeviceStruct struct {
	Package    *packages.Package
	ParamCount int
}

func main() {
	packageData := findRelevantPackages()

	cfg := &packages.Config{
		Mode: packages.LoadTypes,
		Dir:  ".",
	}
	pkgs, err := packages.Load(cfg, ".")
	if err != nil {
		log.Fatalln(err)
	}

	ifaceContents := buildIfaceFile(pkgs[0].Name, packageData)
	err = os.WriteFile("./library/iface.go", []byte(ifaceContents), os.FileMode(0777))
	if err != nil {
		log.Fatalln(err)
	}

	libraryContents := buildLibraryFile(pkgs[0].Name, packageData)
	err = os.WriteFile("./library/library.go", []byte(libraryContents), os.FileMode(0777))
	if err != nil {
		log.Fatalln(err)
	}
}

func libraryHeader(contents *strings.Builder, pkgName string, packageData PackageData) {
	contents.WriteString("// Code generated by library/cmd. DO NOT EDIT.\n")
	contents.WriteString("//\n")

	contents.WriteString(fmt.Sprintf("package %s\n", pkgName))
	contents.WriteRune('\n')
	contents.WriteString("import (\n")

	contents.WriteString(fmt.Sprintf("\t\"%s\"\n", packageData.CorePackagePath))
	contents.WriteString(fmt.Sprintf("\t\"%s\"\n", packageData.Core1_0PackagePath))
	for _, path := range packageData.SortedPackages {
		contents.WriteString(fmt.Sprintf("\t\"%s\"\n", path))
	}

	contents.WriteString(")\n")
	contents.WriteString("\n")
}

func buildLibraryFile(pkgName string, packageData PackageData) string {
	var contents strings.Builder
	libraryHeader(&contents, pkgName, packageData)

	contents.WriteString("type extensionLibrary struct {\n")
	contents.WriteString("}\n")
	contents.WriteString("\n")
	contents.WriteString("func NewLibrary() Library {\n")
	contents.WriteString("\treturn &extensionLibrary{}")
	contents.WriteString("}\n")
	contents.WriteString("\n")
	for _, pkgPath := range packageData.SortedPackages {
		pkg, ok := packageData.InstancePackages[pkgPath]
		if !ok {
			continue
		}

		contents.WriteString(fmt.Sprintf("func (l *extensionLibrary) %s(driver core1_0.CoreInstanceDriver) %s.ExtensionDriver {\n", toTitleCase(pkg.Name), pkg.Name))
		contents.WriteString(fmt.Sprintf("\treturn %s.CreateExtensionDriverFromCoreDriver(driver)\n", pkg.Name))
		contents.WriteString("}\n")
		contents.WriteString("\n")
	}
	for _, pkgPath := range packageData.SortedPackages {
		data, ok := packageData.DevicePackages[pkgPath]
		if !ok {
			continue
		}
		contents.WriteString(fmt.Sprintf("func (l *extensionLibrary) %s(driver core1_0.DeviceDriver", toTitleCase(data.Package.Name)))
		if data.ParamCount > 1 {
			contents.WriteString(", instance core.Instance")
		}
		contents.WriteString(fmt.Sprintf(") %s.ExtensionDriver {\n", data.Package.Name))
		contents.WriteString(fmt.Sprintf("\t return %s.CreateExtensionDriverFromCoreDriver(driver", data.Package.Name))
		if data.ParamCount > 1 {
			contents.WriteString(", instance")
		}
		contents.WriteString(")\n")
		contents.WriteString("}\n")
		contents.WriteString("\n")
	}

	return contents.String()
}

func buildIfaceFile(pkgName string, packageData PackageData) string {
	var contents strings.Builder
	libraryHeader(&contents, pkgName, packageData)

	contents.WriteString("type Library interface {\n")
	for _, pkgPath := range packageData.SortedPackages {
		pkg, ok := packageData.InstancePackages[pkgPath]
		if ok {
			contents.WriteString(fmt.Sprintf("\t%s(driver core1_0.CoreInstanceDriver) %s.ExtensionDriver\n", toTitleCase(pkg.Name), pkg.Name))
			continue
		}

		data, ok := packageData.DevicePackages[pkgPath]
		if !ok {
			continue
		}

		contents.WriteString(fmt.Sprintf("\t%s(driver core1_0.DeviceDriver", toTitleCase(data.Package.Name)))
		if data.ParamCount > 1 {
			contents.WriteString(", instance core.Instance")
		}
		contents.WriteString(fmt.Sprintf(") %s.ExtensionDriver\n", data.Package.Name))
	}

	contents.WriteString("}\n")

	return contents.String()
}

func toTitleCase(name string) string {
	nameRunes := []rune(name)
	outNameRunes := make([]rune, 0, len(nameRunes))
	upperNext := true
	for _, r := range nameRunes {
		if r == '_' {
			upperNext = true
			continue
		} else if upperNext {
			r = unicode.ToUpper(r)
			upperNext = false
		}

		outNameRunes = append(outNameRunes, r)
	}

	return string(outNameRunes)
}

func findRelevantPackages() PackageData {
	packageData := PackageData{}

	cfg := &packages.Config{
		Mode: packages.LoadSyntax,
		Dir:  ".",
	}
	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		log.Fatalln(err)
	}

	allPackages := make(map[string]*packages.Package)
	var sortedPackages []string
	packageData.InstancePackages = make(map[string]*packages.Package)
	packageData.DevicePackages = make(map[string]DeviceStruct)

	for _, pkg := range pkgs {
		sortedPackages = append(sortedPackages, pkg.PkgPath)
		allPackages[pkg.PkgPath] = pkg
	}

	sort.Strings(sortedPackages)

	lastRelevantPackagePath := ""

	for _, path := range sortedPackages {
		if len(lastRelevantPackagePath) > 0 && strings.HasPrefix(path, lastRelevantPackagePath) {
			continue
		}

		pkg := allPackages[path]

		pkgTypes := pkg.Types.Scope().Names()

		constructor := false
		driver := false
		name := false
		for _, t := range pkgTypes {
			if t == "ExtensionDriver" {
				driver = true
			} else if t == "CreateExtensionDriverFromCoreDriver" {
				constructor = true
			} else if t == "ExtensionName" {
				name = true
			}
		}

		if !constructor && !driver {
			continue
		}

		if !constructor {
			log.Fatalf("missing CreateExtensionDriverFromCoreDriver in %s but ExtensionDriver is present\n", pkg.PkgPath)
		}

		if !driver {
			log.Fatalf("missing ExtensionDriver in %s but CreateExtensionDriverFromCoreDriver is present\n", pkg.PkgPath)
		}

		if !name {
			log.Fatalf("missing ExtensionName in %s but ExtensionDriver and CreateExtensionDriverFromCoreDriver are present\n", pkg.PkgPath)
		}

		if packageData.CorePackagePath == "" || packageData.Core1_0PackagePath == "" {
			fillPackagePaths(pkg, &packageData)
		}

		for _, fileAst := range pkg.Syntax {
			ast.Inspect(fileAst, func(n ast.Node) bool {
				funcDecl, ok := n.(*ast.FuncDecl)
				if !ok {
					return true
				}

				if funcDecl.Name == nil || funcDecl.Name.Name != "CreateExtensionDriverFromCoreDriver" {
					return true
				}

				isInstance, paramCount := constructorIsInstance(pkg, funcDecl, packageData.Core1_0PackagePath, packageData.CorePackagePath)
				if isInstance {
					packageData.InstancePackages[path] = pkg
				} else {
					packageData.DevicePackages[path] = DeviceStruct{
						Package:    pkg,
						ParamCount: paramCount,
					}
				}
				packageData.SortedPackages = append(packageData.SortedPackages, path)

				return true
			})
		}

		lastRelevantPackagePath = path
	}

	return packageData
}

func fillPackagePaths(pkg *packages.Package, packageData *PackageData) {
	for _, importedPkg := range pkg.Imports {
		path := importedPkg.PkgPath
		if strings.HasSuffix(path, "/core1_0") && strings.HasPrefix(path, "github.com/vkngwrapper/core/") {
			packageData.Core1_0PackagePath = path
		}
	}

	if packageData.Core1_0PackagePath == "" {
		log.Fatalf("package %s did not imported the vkngwrapper core1_0 package", pkg.PkgPath)
	}

	for _, importedPkg := range pkg.Imports {
		path := importedPkg.PkgPath
		if path != packageData.Core1_0PackagePath && strings.HasPrefix(packageData.Core1_0PackagePath, path) {
			packageData.CorePackagePath = path
		}
	}
}

func constructorIsInstance(pkg *packages.Package, decl *ast.FuncDecl, core10Path, corePath string) (instance bool, paramCount int) {
	if decl.Type.Params == nil {
		log.Fatalf("%s/CreateExtensionDriverFromCoreDriver does not have parameters, must have a single parameter of type core1_0.CoreInstanceDriver or core1_0.DeviceDriver\n", pkg.PkgPath)
	}
	if decl.Type.Results == nil {
		log.Fatalf("%s/CreateExtensionDriverFromCoreDriver does not have return values, must have a single return value of type ExtensionDriver\n", pkg.PkgPath)
	}

	params := decl.Type.Params.List
	retVal := decl.Type.Results.List

	// Check return value type
	if len(retVal) != 1 || len(retVal[0].Names) > 1 {
		log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has the wrong number of return values, must have a single return value of type ExtensionDriver\n", pkg.PkgPath)
	}

	retValPath, retValType, ok := extractNamedType(pkg, retVal[0])
	if !ok && retValPath == "" && retValType == "" {
		log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has an incorrect return value, must be of type ExtensionDriver but was not a named type\n", pkg.PkgPath)
	} else if !ok {
		log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has an incorrect return value, must be of type ExtensionDriver but was a type alias named %s/%s\n", pkg.PkgPath, retValPath, retValType)
	}

	if retValType != "ExtensionDriver" {
		log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has an incorrect return value, must be of type ExtensionDriver but was %s\n", pkg.PkgPath, retValType)
	}

	if retValPath != pkg.PkgPath {
		log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has an incorrect return value: the return type is ExtensionDriver but the package is %s instead of %s\n", pkg.PkgPath, retValPath, pkg.PkgPath)
	}

	// Check first parameters
	if len(params) == 0 || len(params) > 2 || len(params[0].Names) != 1 {
		log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has the wrong number of parameters, must have a single parameter of type core1_0.CoreInstanceDriver or a parameter of type core1_0.DeviceDriver and optionally an additional parameter of type core1_0.Instance\n", pkg.PkgPath)
	}

	firstParamPath, firstParamType, ok := extractNamedType(pkg, params[0])
	if !ok && firstParamPath == "" && firstParamType == "" {
		log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has an incorrect parameter, must be of type core1_0.CoreInstanceDriver or core1_0.DeviceDriver but was not a named type\n", pkg.PkgPath)
	} else if !ok {
		log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has an incorrect parameter, must be of type core1_0.CoreInstanceDriver or core1_0.DeviceDriver but was a type alias named %s/%s\n", pkg.PkgPath, firstParamPath, firstParamType)
	}

	if firstParamType != "CoreInstanceDriver" && firstParamType != "DeviceDriver" {
		log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has an incorrect parameter, must be of type core1_0.CoreInstanceDriver or core1_0.DeviceDriver but was %s\n", pkg.PkgPath, firstParamType)
	}

	if firstParamPath != core10Path {
		log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has an incorrect parameter: the type name is correct, but the package is %s instead of %s\n", pkg.PkgPath, firstParamPath, core10Path)
	}

	// Instance constructor should only ever have one param
	if firstParamType == "CoreInstanceDriver" && len(params) != 1 {
		log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has the wrong number of parameters- when the first parameter of type core1_0.CoreInstanceDriver, there should be only one parameter\n", pkg.PkgPath)
	} else if firstParamType == "CoreInstanceDriver" {
		return true, 1
	}

	// Device constructor may have one or two parameters
	if len(params) == 2 {
		// Second parameter must be core.Instance
		secondParamPath, secondParamType, ok := extractNamedType(pkg, params[1])
		if !ok && secondParamPath == "" && secondParamType == "" {
			log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has an incorrect parameter, second parameter must be of type core.Instance but was not a named type\n", pkg.PkgPath)
		} else if !ok {
			log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has an incorrect parameter, second parameter must be of type core.Instance but was a type alias named %s/%s\n", pkg.PkgPath, secondParamPath, secondParamType)
		}

		if secondParamType != "Instance" {
			log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has an incorrect parameter, must be of type core.Instance but was %s\n", pkg.PkgPath, secondParamType)
		}

		if secondParamPath != corePath {
			log.Fatalf("%s/CreateExtensionDriverFromCoreDriver has an incorrect second parameter: the type name is correct but the package is %s instead of %s\n", pkg.PkgPath, secondParamPath, corePath)
		}
	}

	// It's valid, so is it instance or device?
	return false, len(params)
}

func extractNamedType(pkg *packages.Package, field *ast.Field) (path, typeName string, ok bool) {
	typeInfo, ok := pkg.TypesInfo.Types[field.Type]
	if !ok {
		return "", "", false
	}

	named, ok := typeInfo.Type.(*types.Named)
	if !ok {
		return "", "", false
	}

	path = named.Obj().Pkg().Path()
	typeName = named.Obj().Name()

	for named.Obj().IsAlias() {
		named, ok = named.Underlying().(*types.Named)
		if !ok {
			return path, typeName, false
		}
	}

	path = named.Obj().Pkg().Path()
	typeName = named.Obj().Name()

	return path, typeName, true
}
